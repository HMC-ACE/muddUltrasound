"""
Alec Vercruysse

This module contains code for running different types of swept-beam imaging.

The top-level imaging functions that can be run are:
  - ``spherical_scan`` 
        (old, scan a range of theta & phi, finding and returning 
        the first peak, and visualizing in 3D)
  - ``spherical_scan_all_peaks`` 
        (scan a range of theta & phi, finding and 
        returning *multiple* peaks per capture, and visualizing in 3D)
  - ``scan_x_slice`` 
        (scan accross the x direction, centered vertically,
        visualizing the result like a ultrasound scan in 2D).
  - ``scan_y_slice`` 
        (scan accross the y direction, centered horizontally,
        visualizing the result like an ultrasound scan in 2D).

``spherical_scan_all_peaks`` provides the best results in 3D. Running 
this module directly will run such a scan and produce a figure.

These scans all take a very long time to run due to limitations of the
architecture of the system itself: all raw scan data has to be offloaded
to the computer via the slow and marginal i2c bus, one channel at a time,
before the delay-and-sum, enveloping, and peak-detection is completed.
To speed up debug (as well as have a log of the images we've taken),
the raw adc data can be saved, allowing for a "replay" of the algorithm,
with ADC data stored in files rather than being generated in real-time
by the array. See ``visualize.py`` for the functions that do this for the
spherical imaging scans.
"""

import time

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors
from pyftdi.ftdi import FtdiError
from pyftdi.i2c import I2cNackError
from scipy.signal import butter, filtfilt, find_peaks

from datetime import datetime
import os
import logging
import subprocess
import glob
import pdb

import i2c_cmd
import image

# TODO some of these functions should probably be methods of i2c_cmd.PhasedArray

steps = 10


def get_echo_DAS(array, theta, phi, max_dist=None, log=None, label=""):
    """
    Given a direction, aim the beam, perform a pulse, and return the
    delay-and-summed echo data.

    Parameters
    ----------
    array : i2c_cmd.PhasedArray object
    theta : float
        angle from the z-axis in radians
    phi : float
        angle from the x-axis in the x-y plane
    max_dist : float
        the maximum range for which the echo should be retrieved.
        setting this allows the function to return more quickly since
        less data will need to be read from the MCU.
    log : string or None
        path (folder) to log the raw ADC reads from, or None
    label : string
        additional string to append to the autogenerated path name if
        logging the pulse.

    Returns
    -------
    echo : np.array
        time-series delay-summed echo data (sampled at 1 MHz)
    """
    array.aim_beam_spherical(theta, phi)
    array.send_pulse()
    signals = array.send_read(max_dist=max_dist)
    if log:
        np.save(
            os.path.join(
                log,
                f"signals_{theta=:.2f}_{phi=:.2f}_{max_dist=}_{label}.npy"),
            signals)
    echo = image.get_das(signals, theta=theta, phi=phi)
    return echo


def first_peak(envelope, pct=0.3, visualize=True, ax=None):
    """
    Finds the index of the first peak in the envelope. Naive algorithm.
    Selects the first peak by finding the point where the data goes
    above the mean value + `pct` from mean to max, and where the data goes back
    under. then finds the argmax in that section.

    Parameters
    ----------
    envelope : array
        time-series envelope data.
    pct : float
        the amount of above the mean (the range of mean to max scaled by pct)
        to find the peak section to argmax.
    visualize : bool
        whether or not to plot a graph (non-blocking) showing the peak
        and treshold.
    ax : matplotlib axes object or None
        if `visualize` is True, the axis to do the visualization on.

    Returns
    -------
    peak_idx : integer
        index of the first peak in the array.
    """
    mean = np.mean(envelope)
    mx = np.max(envelope)
    thresh = mean + pct * (mx - mean)
    start_idx = np.argmax(envelope > thresh)
    end_idx = start_idx + np.argmax(envelope[start_idx:] < thresh)
    peak_idx = start_idx + np.argmax(envelope[start_idx:end_idx])
    if visualize:
        if ax is None:
            ax = plt.gca()
        ax.plot(np.arange(len(envelope)), envelope)
        ax.plot([0, len(envelope)], [thresh, thresh])
        ax.scatter(peak_idx, envelope[peak_idx])
        plt.draw()
        plt.pause(0.001)
    return peak_idx


def ac_couple(data, fs=1e6, cutoff=15000):
    """
    Perform a 1st-rder high-pass filter on the time-series data to
    AC-couple it (analagous to an R/C filter).

    Parameters
    ----------
    data : np.array
        time-series signal
    fs : float
        sampling frequency
    cutoff : float
        cutoff frequency of the filter in Hz

    Returns
    -------
    high_passed : np.array
        filtered data
    """
    nyq = fs / 2
    normal_cutoff = cutoff / nyq
    b, a = butter(1, normal_cutoff, btype='high',
                  analog=False)  # filter coefficients
    high_passed = filtfilt(b, a, data)  # like a simple R/C filter
    return high_passed


def halfwave_lowpass(data, cutoff=1e4, fs=1e6):
    """
    Simple envelope function, half-wave rectification + low-pass filter.
    Analogous to the diode+capacitor in a simple AM demodulator.

    Parameters
    ----------
    data : np.array
        time-series signal.
    cutoff : float
        cutoff frequency in Hz of the lowpasss filter post-rectification.
    fs : float
        sampling frequency of the data.

    Returns
    -------
    envelope : np.array
        envelope of the time-series signal
    """
    nyq = fs / 2
    data = ac_couple(data)
    data[data < 0] = 0  # halfwave rectify
    normal_cutoff = cutoff / nyq
    b, a = butter(1, normal_cutoff, btype='low',
                  analog=False)  # filter coefficients
    envelope = filtfilt(b, a, data)  # like a simple R/C filter
    return envelope


def bandpass(data, bandwidth=2e4, fs=1e6):
    """
    3rd-order bandpass filter.

    Parameters
    ----------
    data : np.array
        time-series signal
    bandwidth : integer
        bandwidth in Hz.
    fs : integer
        sampling frequency of the data.

    Returns
    -------
    filtered : np.array
        filtered time-series signal.
    """
    center = 92700  # Hz
    data = ac_couple(data)
    corners = (center - bandwidth/2, center + bandwidth/2)
    b, a = butter(3, corners, btype='bandpass',
                  analog=False, fs=fs)  # filter coefficients
    filtered = filtfilt(b, a, data)  # like a simple R/C filter
    return filtered


def get_range(array, theta, phi, max_dist,
              envelope=halfwave_lowpass,
              peak_idx=first_peak,
              visualize=True, debug_fig=None,
              log=None, label=""):
    """
    Find the range of an object in the (theta, phi) direction by finding the
    first peak in the envelope of a delay-and-summed echo by sending a ping
    in that direction.

    Kwargs allow for visualization (non-blocking) and logging of the data.

    Parameters
    ----------
    array : i2c_cmd.PhasedArray
    theta : float
        angle from the z-axis in radians
    phi : float
        angle from the x-axis in the x-y plane
    max_dist : float
        the maximum range for which the echo should be retrieved.
        setting this allows the function to return more quickly since
        less data will need to be read from the MCU.
    envelope : function
        function operating on time-series data that returns its envelope
    peak_idx : function
        function operating on time-series data that returns the first peak
        (see src for visualization-related kwargs it must accept)
    visualize : bool
        whether or not to visualize the the envelope of the signal and
        the first peak computed (non-blocking).
    debug_fig : matplotlib figure object or None
        either a matplotlib figure with at least two axis on which the
        visualization will be plotted, or None, in which case a figure
        will be created.
    log : string or None
        path (folder) to log the raw ADC reads from, or None
    label : string
        additional string to append to the autogenerated path name if
        logging the pulse.

    Returns
    -------
    r : float
        the range that the first found echo correpsonds to
    mag : float
        the magnitude of the enveloped signal that the peak corresponds to

    """
    if visualize is True:
        if debug_fig is None:
            debug_fig = plt.figure()
        if not debug_fig.get_axes():
            new_fig = True
            ax_peak = debug_fig.add_subplot(211)
            ax_range = debug_fig.add_subplot(212)
        else:
            ax_peak = debug_fig.get_axes()[0]
            ax_range = debug_fig.get_axes()[1]
            ax_peak.clear()
            ax_range.clear()
            new_fig = False

    echo = get_echo_DAS(array,
                        theta,
                        phi,
                        max_dist=max_dist,
                        log=log,
                        label=label)
    env = envelope(echo)
    try:
        idx = peak_idx(env, ax=ax_peak)
    except ValueError:
        print(env)
        raise
    r = array.idx_to_range(idx)

    if visualize:
        ax_range.plot(array.idx_to_range(np.arange(len(env))), env)
        ax_range.scatter(array.idx_to_range(idx), env[idx], c='red')
        if new_fig:
            ax_range.set_xlabel("echo range [m]")
            ax_range.set_ylabel("delay and summed return signal envelope")
        ax_range.set_title(f"Range-finding results for {theta=}, {phi=}")
        plt.draw()
        plt.pause(0.001)
    return r, env[idx]


def find_env_peaks(envelope, visualize=False, ax=None):
    """
    Find all relevant peaks in an envelope, returning an array of indexes.
    This more or less wraps scipy's `signal.find_peaks` method, calling it
    with a `prominence` argument based on some percentage of the maximum
    of the given envelope. See the scipy doc for more details on
    topographic prominence.

    Parameters
    ----------
    envelope : np.array
        time-series envelope of the signal
    visualize : bool
        if True, visualize the peak-detection algorithm by plotting all
        peaks in the envelope and the threshold for prominence
        each neighboring dip (by plotting the envelope plus the prominence
        threhsold for all points)
    ax : matplotlib axes object
        if `visualize` is true, a set of axes on which to plot.

    Returns
    -------
    peaks : np.array
        all peaks as indexes
    """
    peaks, _ = find_peaks(envelope, prominence=np.max(envelope) / 5)
    if visualize:
        if ax is None:
            ax = plt.gca()
        ax.plot(np.arange(len(envelope)), envelope)
        ax.plot(np.arange(len(envelope)), envelope + np.max(envelope) / 5)
        ax.scatter(peaks, envelope[peaks], c='red')
        plt.draw()
        plt.pause(0.001)
    return peaks


def find_env_peaks_experimental(envelope):
    """
    Drop-in replacement for `find_env_peaks` without visualization
    capabilities. Used in ``visualize.py`` to visualize an alternative
    peak-finding method based solely on absolute height rather
    than prominence.

    Parameters
    ----------
    envelope : np.array
        time-series envelope of signal

    Returns
    -------
    peaks : np.array
        list of peaks as indexes
    """
    peaks, _ = find_peaks(envelope, height=0.0001)
    return peaks


def get_peaks(array,
              theta,
              phi,
              max_dist,
              envelope=halfwave_lowpass,
              find_peaks=find_env_peaks,
              visualize=True,
              debug_fig=None,
              log=None,
              label=""):
    """
    This is to `spherical_scan_all_peaks` what `get_range` is to
    `spherical_scan`. The big difference in args is the `find_peaks`
    kwarg in place of `peak_idx`.

    Find the range of potential object(s) in the (theta, phi) direction by
    finding the peaks in the envelope of a delay-and-summed echo by sending
    a ping in that direction.

    Parameters
    ----------
    array : i2c_cmd.PhasedArray
    theta : float
        angle from the z-axis in radians
    phi : float
        angle from the x-axis in the x-y plane
    max_dist : float
        the maximum range for which the echo should be retrieved.
        setting this allows the function to return more quickly since
        less data will need to be read from the MCU.
    envelope : function
        function operating on time-series data that returns its envelope
    find_peaks: function
        function operating on time-series data that returns all peaks
        (see src for visualization-related kwargs it must accept)
    debug_fig : matplotlib figure object or None
        either a matplotlib figure with at least two axis on which the
        visualization will be plotted, or None, in which case a figure
        will be created.
    log : string or None
        path (folder) to log the raw ADC reads from, or None
    label : string
        additional string to append to the autogenerated path name if
        logging the pulse.

    Returns
    -------
    r : float
        the range that all found peaks correspond to
    mag : float
        the magnitude of the enveloped signal that each peak corresponds to
    """
    if visualize is True:
        if debug_fig is None:
            debug_fig = plt.figure()
        if not debug_fig.get_axes():
            new_fig = True
            ax_peak = debug_fig.add_subplot(211)
            ax_range = debug_fig.add_subplot(212)
        else:
            ax_peak = debug_fig.get_axes()[0]
            ax_range = debug_fig.get_axes()[1]
            ax_peak.clear()
            ax_range.clear()
            new_fig = False

    echo = get_echo_DAS(array,
                        theta,
                        phi,
                        max_dist=max_dist,
                        log=log,
                        label=label)
    env = envelope(echo)
    peaks = find_env_peaks(env, visualize=visualize, ax=ax_peak)
    rs = array.idx_to_range(peaks)

    if visualize:
        ax_range.plot(array.idx_to_range(np.arange(len(env))), env)
        ax_range.scatter(array.idx_to_range(peaks), env[peaks], c='red')
        if new_fig:
            ax_range.set_xlabel("echo range [m]")
            ax_range.set_ylabel("delay and summed return signal envelope")
        ax_range.set_title(f"Range-finding results for {theta=}, {phi=}")
        plt.draw()
        plt.pause(0.001)
    return rs, env[peaks]


def spherical_scan(array,
                   r_range=(1.5, 5),
                   theta_range=(0, np.pi / 4),
                   phi_range=(0, 2 * np.pi),
                   steps=steps,
                   visualize_debug=True,
                   peak_idx=first_peak,
                   envelope=halfwave_lowpass,
                   log="data/"):
    """
    Performs the imaging scan discussed with Prof. Spencer 2021-06-11.
    Scans through `theta` and `phi` of a spherical coordinate system
    by steering a beam in that direction and recieving the echo
    with delay-and-sum, and uses the peak finding function `peak_idx`
    and the envelope function `envelope` to return the nearest echo and
    its magnitude.

    This plots the image in 3D space.

    Parameters
    ----------
    array: i2c_cmd.PhasedArray
        PhasedArray object
    r_range: tuple
        range of possible r values (in meters).
        The minimum is limited by the time delay between the start of the pulse
        and the start of the most delayed channel's ADC capture.
        (TODO the min range logic here).
    theta_range : tuple
        range of possible `theta` (degrees) to scan.
        Generally sidelobe-dependent.
        Array lies on z-axis, 0 - pi/4 radians is acceptable.
    phi_range : tuple
        range of possible `phi` to scan. All 2-pi radians is default.
    steps : integer
        the number of points to sample in each angular range (theta and phi)
    visualize_debug : bool
        whether or not to visualize the peak-finding in each delay-and-summed
        signal (see `get_range` for plotting details). Non-blocking.
    peak_idx : function
        function operating on time-series data that returns the first peak
        (see `get_range` src for visualization-related kwargs it must accept)
    envelope : function
        function operating on time-series data that returns its envelope
    log : string or None
        path to log folder in which each run of this command will create a
        unique subdirectory with all raw ADC echo data. To remain unique,
        each folder is titled with the date and time of the scan run. This
        means that no two spherical scans can be started in the same minute,
        which, unless debugging, never happens since scans take so long.
        This script also produces a log file with the setup as well as
        parameters and potential i2c issues encountered during the run.

    Returns
    -------
    mags : np.array
        list of magnitudes corresponding to each peak in the final image.
    rs : np.array
        list of ranges corresponding to each peak in the final image.
    mphi : np.array
        list of `phi` angles corresponding to each peak in the final image.
    mtheta : np.array
        list of `theta` angles corresponding to each peak in the final image.
    """
    if log is not None:
        folder = datetime.now().strftime("img_%Y-%m-%d--%H-%M/")
        data_path = os.path.join(log, folder)
        os.mkdir(data_path)  # `folder` should be unique
        log_name = os.path.join(data_path, "spherical_scan.log")
        handler = logging.FileHandler(filename=log_name)
        logger = logging.getLogger(__name__)
        logger.setLevel(logging.DEBUG)
        logger.addHandler(handler)
        logging.getLogger('pyftdi').addHandler(handler)

    logger.info("image start")
    hash = subprocess.check_output(["git", "describe", "--always"]).strip()
    logger.info(f"spherical scan params:\n\t{r_range=}\n\t" +
                f"{theta_range=}\n\t{phi_range=}\n\t{steps=}\n\t" +
                f"peak finding function: {peak_idx.__name__}\n\t" +
                f"envelope function: {envelope.__name__}\n\t" +
                f"current commit hash: {hash}")
    warn = "image min range is not implemented. min range " + \
           f"is array delay defined at: {array.idx_to_range(0)} meters"
    logger.warning(warn)
    print(warn)

    averaging_steps = 1
    logger.info(f'{averaging_steps=}')
    tr = np.linspace(*theta_range, num=steps)
    pr = np.linspace(*phi_range, num=steps)
    mags = np.zeros((len(tr), len(pr)))  # magnitude of detected peak
    rs = np.zeros_like(mags)  # distance from peak to home.
    plt.ion()
    fig = plt.figure()
    ax_main = fig.add_subplot(111, projection='3d')
    ax_main.set_xlabel("x [m]")
    ax_main.set_ylabel("y [m]")
    scatter = ax_main.scatter3D(0, 0, 0, c=0)
    cbar = fig.colorbar(scatter)
    cbar.ax.set_title("peak magnitude")
    if visualize_debug:
        fig_debug = plt.figure()

    mphi, mtheta = np.meshgrid(pr, tr)
    for tidx, theta in enumerate(tr):
        for pidx, phi in enumerate(pr):
            msg = f"starting {theta=}, {phi=} pulse..."
            logger.debug(msg)
            print(msg)
            for iteration in range(averaging_steps):
                try:
                    r, mag = get_range(array,
                                       theta,
                                       phi,
                                       r_range[1],
                                       envelope=envelope,
                                       peak_idx=peak_idx,
                                       visualize=True,
                                       debug_fig=fig_debug,
                                       log=data_path,
                                       label=iteration)
                except (ValueError) as E:
                    logger.error(
                        f"Exception in get_range: {E}\n" +
                        "setting r/mag = 0, waiting 1 second, continuing")
                    r, mag = (0, 0)
                    time.sleep(1)
                except FtdiError as E:
                    logger.critical(
                        f"Error connecting to FTDI chip: {E}\n aborting.")
                    raise
                except I2cNackError as E:
                    logger.critical(f"I2C bus error: {E}\n aborting.")
                    if input("i2c bus error. cleanup? y/[n]") == 'y':
                        os.remove(os.path.join(folder, "/*"))
                        os.rmdir(folder)
                        raise
                rs[tidx][pidx] += r
                mags[tidx][pidx] += mag  # env[idx]
            rs[tidx][pidx] /= averaging_steps
            mags[tidx][pidx] /= averaging_steps

            # plot:
            x = rs * np.sin(mtheta) * np.cos(mphi)
            y = rs * np.sin(mtheta) * np.sin(mphi)
            z = rs * np.cos(mtheta)
            ax_main.clear()
            ax_main.set_xlabel("x [m]")
            ax_main.set_ylabel("y [m]")
            ax_main.set_zlabel("z [m] (broadside)")
            ax_main.scatter3D(0, 0, 0, c='red')
            scatter = ax_main.scatter3D(x, y, z, c=mags)
            cbar.update_normal(scatter)
            plt.draw()
            plt.pause(0.001)
    logger.info("done.")
    return mags, rs, mphi, mtheta


def spherical_scan_all_peaks(array,
                             r_range=(1.5, 5),
                             theta_range=(0, np.pi / 4),
                             phi_range=(0, 2 * np.pi),
                             theta_steps=20,
                             phi_steps=50,
                             visualize_debug=False,
                             envelope=halfwave_lowpass,
                             log="data/",
                             setup="no setup notes"):
    """
    Performs a 3D imaging scan similar to `spherical_scan`, but instead
    of choosing a single peak to plot, it plots all peaks detected.
    This ultimately yields a more informative image as long as proper filtering
    of peaks is applied, possibly in `visualize.py` post-hoc.

    This plots the image in 3D space.

    Parameters
    ----------
    array: i2c_cmd.PhasedArray
        PhasedArray object
    r_range: tuple
        range of possible r values (in meters).
        The minimum is limited by the time delay between the start of the pulse
        and the start of the most delayed channel's ADC capture.
        (TODO the logic here).
    theta_range : tuple
        range of possible `theta` (degrees) to scan.
        Generally sidelobe-dependent.
        Array lies on z-axis, 0 - pi/4 radians is acceptable.
    phi_range : tuple
        range of possible `phi` to scan. All 2-pi radians is default.
    theta_steps : integer
        the number of points to sample in the theta angular range.
    phi_steps : integer
        the number of points to sample in the phi angular range.
    visualize_debug : bool
        whether or not to visualize the peak-finding in each delay-and-summed
        signal (see `get_peaks` for plotting details). Non-blocking.
    envelope : function
        function operating on time-series data that returns its envelope.
    log : string or None
        path to log folder in which each run of this command will create a
        unique subdirectory with all raw ADC echo data. To remain unique,
        each folder is titled with the date and time of the scan run. This
        means that no two spherical scans can be started in the same minute,
        which, unless debugging, never happens since scans take so long.
        Detailed visualization and inspection of the raw data (including of
        the 3D image the scan produces) can be accomplished with `visualize.py`
        This script also produces a log file with the setup as well as
        parameters and potential i2c issues encountered during the run.
    setup : string
        notes on the setup to be logged in the logfile
        (if a log directory is specified).

    Notes
    -----
    While nothing is returned, note that all raw data is saved and 
    `visualize.py` can reproduce the figure that this function produces.
    """
    if log is not None:
        folder = datetime.now().strftime("img_%Y-%m-%d--%H-%M/")
        data_path = os.path.join(log, folder)
        os.mkdir(data_path)  # `folder` should be unique
        log_name = os.path.join(data_path, "spherical_scan_all_peaks.log")
        handler = logging.FileHandler(filename=log_name)
        logger = logging.getLogger(__name__)
        logger.setLevel(logging.DEBUG)
        logger.addHandler(handler)
        logging.getLogger('pyftdi').addHandler(handler)

    logger.info("image start")
    hash = subprocess.check_output(["git", "describe", "--always"]).strip()
    logger.info(f"spherical scan params:\n\t{r_range=}\n\t" +
                f"{theta_range=}\n\t{phi_range=}\n\t{steps=}\n\t" +
                f"envelope function: {envelope.__name__}\n\t" +
                f"current commit hash: {hash}\n\t" + f"setup: {setup}")
    warn = "image min range is not implemented. min range " + \
           f"is array delay defined at: {array.idx_to_range(0)} meters"
    logger.warning(warn)
    print(warn)

    averaging_steps = 1
    logger.info(f'{averaging_steps=}')
    tr = np.linspace(*theta_range, num=theta_steps)
    pr = np.linspace(*phi_range, num=phi_steps)
    results = []

    # since each pulse can have an arbitrary number of peaks,
    # we store the array as a list of [theta, phi, r, mag] values.
    plt.ion()
    fig = plt.figure()
    ax_main = fig.add_subplot(111, projection='3d')
    ax_main.set_xlabel("x [m]")
    ax_main.set_ylabel("y [m]")
    scatter = ax_main.scatter3D(0, 0, 0, c=0)
    cbar = fig.colorbar(scatter)
    cbar.ax.set_title("peak magnitude")
    if visualize_debug:
        fig_debug = plt.figure()

    for tidx, theta in enumerate(tr):
        for pidx, phi in enumerate(pr):
            msg = f"starting {theta=}, {phi=} pulse..."
            logger.debug(msg)
            print(msg)
            for iteration in range(averaging_steps):
                try:
                    rs, mags = get_peaks(array,
                                         theta,
                                         phi,
                                         r_range[1],
                                         envelope=halfwave_lowpass,
                                         visualize=True,
                                         debug_fig=fig_debug,
                                         log=data_path,
                                         label=iteration)
                    results += list(
                        zip([theta for _ in range(len(rs))],
                            [phi for _ in range(len(rs))], rs, mags))
                except (ValueError) as E:
                    logger.error(
                        f"Exception in get_range: {E}\n" +
                        "discarding peaks, waiting 1 second, continuing")
                    time.sleep(1)
                except FtdiError as E:
                    logger.critical(
                        f"Error connecting to FTDI chip: {E}\n aborting.")
                    raise
                except I2cNackError as E:
                    logger.critical(f"I2C bus error: {E}\n aborting.")
                    if input("i2c bus error. cleanup? y/[n]") == 'y':
                        for f in glob.glob(os.path.join(data_path, "*")):
                            os.remove(f)
                        os.rmdir(data_path)
                        raise
            # pdb.set_trace()
            r = np.array(results)
            plot_cloud(r, ax=ax_main, cbar=cbar)

    logger.info("done.")
    return


def plot_cloud(data, ax=None, cbar=None):
    """
    Plot a point cloud. Click on the colorbar to filter out points
    whose magnitudes are lower than the specified threshold.
    
    TODO: the colorbar filtering only seems to work when invoked by
    `visualize.py` and not when invoked by `spherical_scan_*`

    Parameters
    ----------
    data : np.array, size (n, 4)
        point-cloud data, where the second axis is
        [theta, phi, r, magnitude]
    ax : matplotlib axes object or None
        The axes on which to plot the data. If None, a new figure
        will be created. If `ax` is passed, it must be a 3D projection.
    cbar : matplotlib colorbar object.
        The colorbar object that  displays the colorbar for
        potentially pre-existing points on the axis. If invoking
        `point_cloud` multiple times, this needs to be kept and passed.

    Returns
    -------
    ax : matplotlob axis object
        In case of multiple calls to `plot_cloud` in order to update the plot,
        the axes is returned.
    cbar : matplotlib colorbar object
        In case of multiple calls to `plot_cloud` in order to update the plot,
        the colorbar object is returned.
    """
    def _update_plot(data_view, ax, preserve=False):
        thetas = data_view[:, 0]
        phis = data_view[:, 1]
        rs = data_view[:, 2]
        mags = data_view[:, 3]
        x = rs * np.sin(thetas) * np.cos(phis)
        y = rs * np.sin(thetas) * np.sin(phis)
        z = rs * np.cos(thetas)
        if preserve:  # if not None, `preserve` is cmap bounds
            xlim = ax.get_xlim()
            ylim = ax.get_ylim()
            zlim = ax.get_zlim()
        ax.clear()
        ax.set_xlabel("x [m]")
        ax.set_ylabel("y [m]")
        ax.set_zlabel("z [m] (broadside)")
        ax.scatter3D(0, 0, 0, c='red')  # origin in red
        vmin = None if not preserve else preserve[0]
        vmax = None if not preserve else preserve[1]
        scatter = ax.scatter3D(x,
                               y,
                               z,
                               c=mags,
                               norm=matplotlib.colors.LogNorm(vmin=vmin,
                                                              vmax=vmax))
        if preserve:
            ax.set_xlim(xlim)
            ax.set_ylim(ylim)
            ax.set_zlim(zlim)
        plt.draw()
        plt.pause(0.01)
        return scatter

    def _on_pick(event):
        nonlocal data, scatter, ax, cbar
        val = event.mouseevent.ydata
        data_view = np.ma.masked_where((data[:, 3] <= val)[:, None]
                                       * np.ones((1, 4)), data)
        markers = list(filter(lambda x: x.get_label() == 'thresh_marker',
                              cbar.ax.get_children()))
        if len(markers) != 0:
            markers[0].set_data([0, 1], [val, val])
        else:
            cbar.ax.plot([0, 1], [val, val], 'red', label='thresh_marker')

        # this will also redraw (update the cbar line)
        _update_plot(data_view, ax, preserve=(scatter.norm.vmin,
                                              scatter.norm.vmax))

    data_view = data.view(np.ma.MaskedArray)  # masked array for plotting
    if ax is None:
        _, ax = plt.subplots(subplot_kw={'projection': '3d'})
    scatter = _update_plot(data_view, ax)
    if cbar is None:
        cbar = plt.gcf().colorbar(scatter)
    cbar.update_normal(scatter)

    if hasattr(plot_cloud, "callback"):  # need to remove prev callback
        plt.gcf().canvas.mpl_disconnect(plot_cloud.callback)
    cbar.ax.set_picker(True)
    plot_cloud.callback = plt.gcf().canvas.mpl_connect('pick_event', _on_pick)
    return ax, cbar


def scan_x_slice(max_angle=.3, max_dist=5, steps=100, apply_bandpass=False):
    """
    Scan accross the x-axis, vertically centered.
    Produce a 2D scan image similar to a medical ultrasound.

    Parameters
    ----------
    max_angle : float
        maximum angle away from the center, in "units" of *directional cosine*,
        to scan the array.
    max_dist : float
        the maximum range for which the echo should be retrieved.
        setting this allows the function to return more quickly since
        less data will need to be read from the MCU.
    steps : integer 
        The number of steps between the leftmost and rightmost angles to scan.
        This is the number of pulses that are sent out, and affects resolution.
    apply_bandpass : bool
        Whether or not to apply `das_scan.bandpass` to the raw adc data in order
        to reduce noise.

    Returns
    -------
    r : np.array
        array containing all points in the final image. It has shape (n, 4)
        where n is a large number of points. Each point appears as a row,
        the first column describes the x-directional cosine of the point,
        the second the y-directional cosine of the point, the third 
        describes the radius from the center, and the last describes the
        magnitude of the point (the magnitude of the envelope function 
        evaluated at the point).

    Notes
    -----
    This is an imaging function and ultimately produces a figure via matplotlib
    (that can be saved). The return value is mainly for debugging/recreating 
    the plot with different parameters.
    """
    alphas = np.sin(np.linspace(-max_angle, max_angle, steps))
    betas = np.zeros_like(alphas)
    results = []
    a = i2c_cmd.PhasedArray()
    for alpha, beta in zip(alphas, betas):
        print(f"{alpha=}")
        a.aim_beam_directional_cosine(alpha, beta)
        time.sleep(0.3)
        a.send_pulse()
        time.sleep(0.3)
        signals = a.send_read(max_dist=max_dist)
        if apply_bandpass:
            signals = np.apply_along_axis(bandpass, 2, signals)  # EXPERIMENTAL
        echo = image.get_das(signals, alpha=alpha, beta=beta)
        env = halfwave_lowpass(echo)
        # peaks = find_env_peaks(env, visualize=False)
        sample_points = np.arange(0, len(env), step=20)
        rs = a.idx_to_range(sample_points)
        mags = env[sample_points]
        results += list(
            zip([alpha for _ in range(len(rs))],
                [beta for _ in range(len(rs))], rs, mags))

    fig, ax = plt.subplots()
    r = np.array(results)
    alphas = r[:, 0]
    betas = r[:, 1]
    rs = r[:, 2]
    mags = r[:, 3]
    x = rs * alphas
    z = rs * np.cos(np.arcsin(alphas))
    mags[mags <= 0] = 0.0001
    plt.scatter(x, z, c=mags)#, norm=matplotlib.colors.LogNorm())
    plt.title("x slice")
    # plt.tricontourf(x, z, mags, norm=matplotlib.colors.LogNorm())
    plt.show()
    return r


def scan_y_slice(max_angle=.3, max_dist=5, steps=50, apply_bandpass=False):
    """
    Scan accross the y-axis, horizontally centered.
    Produce a 2D scan image similar to a medical ultrasound.

    Parameters
    ----------
    max_angle : float
        maximum angle away from the center, in "units" of *directional cosine*,
        to scan the array.
    max_dist : float
        the maximum range for which the echo should be retrieved.
        setting this allows the function to return more quickly since
        less data will need to be read from the MCU.
    steps : integer 
        The number of steps between the leftmost and rightmost angles to scan.
        This is the number of pulses that are sent out, and affects resolution.
    apply_bandpass : bool
        Whether or not to apply `das_scan.bandpass` to the raw adc data in order
        to reduce noise.

    Returns
    -------
    r : np.array
        array containing all points in the final image. It has shape (n, 4)
        where n is a large number of points. Each point appears as a row,
        the first column describes the x-directional cosine of the point,
        the second the y-directional cosine of the point, the third 
        describes the radius from the center, and the last describes the
        magnitude of the point (the magnitude of the envelope function 
        evaluated at the point).

    Notes
    -----
    This is an imaging function and ultimately produces a figure via matplotlib
    (that can be saved). The return value is mainly for debugging/recreating 
    the plot with different parameters.
    """
    betas = np.sin(np.linspace(-max_angle, max_angle, steps))
    alphas = np.zeros_like(betas)
    results = []
    a = i2c_cmd.PhasedArray()
    for alpha, beta in zip(alphas, betas):
        print(f"{beta=}")
        a.aim_beam_directional_cosine(alpha, beta)
        time.sleep(0.3)
        a.send_pulse()
        time.sleep(0.3)
        signals = a.send_read(max_dist=max_dist)
        if apply_bandpass:
            signals = np.apply_along_axis(bandpass, 2, signals)  # EXPERIMENTAL
        echo = image.get_das(signals, alpha=alpha, beta=beta)
        env = halfwave_lowpass(echo)
        # peaks = find_env_peaks(env, visualize=False)
        sample_points = np.arange(0, len(env), step=20)
        rs = a.idx_to_range(sample_points)
        mags = env[sample_points]
        results += list(
            zip([alpha for _ in range(len(rs))],
                [beta for _ in range(len(rs))], rs, mags))

    fig, ax = plt.subplots()
    r = np.array(results)
    alphas = r[:, 0]
    betas = r[:, 1]
    rs = r[:, 2]
    mags = r[:, 3]
    y = rs * betas
    z = rs * np.cos(np.arcsin(betas))
    mags[mags <= 0] = 0.0001
    plt.scatter(y, z, c=mags)#, norm=matplotlib.colors.LogNorm())
    plt.title("y slice")
    # plt.tricontourf(y, z, mags, norm=matplotlib.colors.LogNorm())
    plt.show()
    return r


if __name__ == "__main__":
    print("starting img")
    array = i2c_cmd.PhasedArray()
    setup = input("setup: ")
    spherical_scan_all_peaks(array, theta_range=(0, np.pi/8), setup=setup)
    plt.show()
